"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var tiny_warning_1 = __importDefault(require("tiny-warning"));
var tiny_invariant_1 = __importDefault(require("tiny-invariant"));
var AsyncUtils_1 = require("./AsyncUtils");
var DOMUtils_1 = require("./DOMUtils");
var PathUtils_1 = require("./PathUtils");
var LocationUtils_1 = require("./LocationUtils");
var DOMStateStorage_1 = require("./DOMStateStorage");
var runTransitionHook_1 = __importDefault(require("./runTransitionHook"));
var Actions_1 = __importStar(require("./Actions"));
var HashChangeEvent = 'hashchange';
function createHashHistory(options) {
    if (options === void 0) { options = {}; }
    tiny_invariant_1.default(DOMUtils_1.canUseDOM, 'Hash history needs a DOM');
    var queryKey = options.queryKey, _a = options.hashType, hashType = _a === void 0 ? 'slash' : _a, keyLength = options.keyLength;
    tiny_warning_1.default(queryKey !== 'false', 'Using { queryKey: false } no longer works. Instead, just don\'t ' +
        'use location state if you don\'t want a key in your URL query string');
    var DefaultQueryKey = '_k';
    function addLeadingSlash(path) {
        return path.charAt(0) === '/' ? path : '/' + path;
    }
    var HashPathCoders = {
        hashbang: {
            encodePath: function (path) { return (path.charAt(0) === '!' ? path : '!' + path); },
            decodePath: function (path) { return (path.charAt(0) === '!' ? path.substring(1) : path); }
        },
        noslash: {
            encodePath: function (path) { return (path.charAt(0) === '/' ? path.substring(1) : path); },
            decodePath: addLeadingSlash
        },
        slash: {
            encodePath: addLeadingSlash,
            decodePath: addLeadingSlash
        }
    };
    var pathCoder = HashPathCoders[hashType];
    if (typeof queryKey !== 'string')
        queryKey = DefaultQueryKey;
    if (hashType == null)
        hashType = 'slash';
    if (!(hashType in HashPathCoders)) {
        tiny_warning_1.default(false, "Invalid hash type: " + hashType);
        hashType = 'slash';
    }
    // Base
    var getUserConfirmation = options.getUserConfirmation || LocationUtils_1.defaultGetUserConfirmation;
    // Hash
    function pushHashPath(path) {
        return window.location.hash = path;
    }
    function replaceHashPath(path) {
        var hashIndex = window.location.href.indexOf('#');
        window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
    }
    var prevLocation;
    function updateLocationHash(location, pathCoder, queryKey, updateHash) {
        var state = location.state, key = location.key;
        var path = pathCoder.encodePath(PathUtils_1.createPath(location));
        if (state !== void 0) {
            path = PathUtils_1.addQueryStringValueToPath(path, queryKey, key);
            DOMStateStorage_1.saveState(key, state);
        }
        prevLocation = __assign({ basename: '', query: {} }, location);
        updateHash(path);
    }
    function pushLocationHash(location, pathCoder, queryKey) {
        updateLocationHash(location, pathCoder, queryKey, function (path) {
            if (getHashPath() !== path) {
                pushHashPath(path);
            }
            else {
                tiny_warning_1.default(false, 'You cannot PUSH the same path using hash history');
            }
        });
        return true;
    }
    function replaceLocationHash(location, pathCoder, queryKey) {
        updateLocationHash(location, pathCoder, queryKey, function (path) {
            if (getHashPath() !== path)
                replaceHashPath(path);
        });
        return true;
    }
    function getHashPath() {
        // We can't use window.location.hash here because it's not
        // consistent across browsers - Firefox will pre-decode it!
        var href = window.location.href;
        var hashIndex = href.indexOf('#');
        return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
    }
    function getCurrentLocationHash(pathCoder, queryKey) {
        var path = pathCoder.decodePath(getHashPath());
        var key = PathUtils_1.getQueryStringValueFromPath(path, queryKey);
        var state;
        if (key) {
            path = PathUtils_1.stripQueryStringValueFromPath(path, queryKey);
            state = DOMStateStorage_1.readState(key);
        }
        var init = PathUtils_1.parsePath(path);
        var newInit = Object.assign(init, { state: state });
        return LocationUtils_1.createLocation(newInit, void 0, key);
    }
    function startListenerHash(callback, pathCoder, queryKey) {
        function handleHashChange( /* event: PopStateEvent */) {
            var path = getHashPath();
            var encodedPath = pathCoder.encodePath(path);
            if (path !== encodedPath) {
                // Always be sure we have a properly-encoded hash.
                replaceHashPath(encodedPath);
            }
            else {
                var currentLocation_1 = getCurrentLocationHash(pathCoder, queryKey);
                // Ignore extraneous hashchange events
                if (prevLocation) {
                    if (currentLocation_1.key
                        && prevLocation.key === currentLocation_1.key) {
                        return;
                    }
                    var curPath = currentLocation_1.pathname + currentLocation_1.search;
                    var prevPath = prevLocation.pathname + prevLocation.search;
                    // prepend basename if existed
                    if (prevLocation.basename) {
                        prevPath = prevLocation.basename + prevPath;
                    }
                    if (prevPath === curPath) {
                        return;
                    }
                }
                prevLocation = __assign({ basename: '', query: {} }, currentLocation_1);
                callback(currentLocation_1);
            }
        }
        // Ensure the hash is encoded properly.
        var path = getHashPath();
        var encodedPath = pathCoder.encodePath(path);
        if (path !== encodedPath)
            replaceHashPath(encodedPath);
        DOMUtils_1.addEventListener(window, HashChangeEvent, handleHashChange);
        return function () {
            return DOMUtils_1.removeEventListener(window, HashChangeEvent, handleHashChange);
        };
    }
    // Base
    function getCurrentLocation() {
        return getCurrentLocationHash(pathCoder, queryKey || '');
    }
    function pushLocation(location) {
        return pushLocationHash(location, pathCoder, queryKey || '');
    }
    function replaceLocation(location) {
        return replaceLocationHash(location, pathCoder, queryKey || '');
    }
    var listenerCount = 0;
    var stopListener;
    function startListener(listener, before) {
        if (++listenerCount === 1)
            stopListener = startListenerHash(transitionTo, pathCoder, queryKey || '');
        var unlisten = before
            ? _listenBefore(listener)
            : _listen(listener);
        return function () {
            unlisten();
            if (--listenerCount === 0)
                stopListener();
        };
    }
    var currentLocation;
    var pendingLocation;
    var beforeHooks = [];
    var hooks = [];
    var allKeys = [];
    function getCurrentIndex() {
        if (pendingLocation && pendingLocation.action === Actions_1.default.POP)
            return allKeys.indexOf(pendingLocation.key || '');
        if (currentLocation)
            return allKeys.indexOf(currentLocation.key || '');
        return -1;
    }
    function updateLocation(nextLocation, silence) {
        if (silence === void 0) { silence = false; }
        var currentIndex = getCurrentIndex();
        currentLocation = nextLocation;
        if (currentLocation.action === Actions_1.PUSH) {
            allKeys = __spread(allKeys.slice(0, currentIndex + 1), [currentLocation.key]);
        }
        else if (currentLocation.action === Actions_1.REPLACE) {
            allKeys[currentIndex] = currentLocation.key;
        }
        if (!silence) {
            hooks.forEach(function (hook) { return hook(currentLocation); });
        }
    }
    function _listenBefore(hook) {
        beforeHooks.push(hook);
        return function () {
            return beforeHooks = beforeHooks.filter(function (item) { return item !== hook; });
        };
    }
    function _listen(hook) {
        hooks.push(hook);
        return function () {
            return hooks = hooks.filter(function (item) { return item !== hook; });
        };
    }
    function _createHref(location) {
        return PathUtils_1.createPath(location);
    }
    function confirmTransitionTo(location, callback) {
        AsyncUtils_1.loopAsync(beforeHooks.length, function (index, next, done) {
            runTransitionHook_1.default(beforeHooks[index], location, function (result) {
                return result != null ? done(result) : next();
            });
        }, function (message) {
            if (getUserConfirmation && typeof message === 'string') {
                getUserConfirmation(message, function (ok) { return callback(ok !== false); });
            }
            else {
                callback(message !== false);
            }
        });
    }
    function transitionTo(nextLocation, silence) {
        if (silence === void 0) { silence = false; }
        if ((currentLocation && LocationUtils_1.locationsAreEqual(currentLocation, nextLocation))
            || (pendingLocation && LocationUtils_1.locationsAreEqual(pendingLocation, nextLocation))) {
            return; // Nothing to do
        }
        pendingLocation = nextLocation;
        confirmTransitionTo(nextLocation, function (ok) {
            if (pendingLocation !== nextLocation)
                return; // Transition was interrupted during confirmation
            pendingLocation = null;
            if (ok) {
                // Treat PUSH to same path like REPLACE to be consistent with browsers
                if (nextLocation.action === Actions_1.PUSH) {
                    var prevPath = PathUtils_1.createPath(currentLocation);
                    var nextPath = PathUtils_1.createPath(nextLocation);
                    if (nextPath === prevPath
                        && LocationUtils_1.statesAreEqual(currentLocation.state, nextLocation.state)) {
                        nextLocation.action = Actions_1.REPLACE;
                    }
                }
                if (nextLocation.action === Actions_1.POP) {
                    updateLocation(nextLocation, silence);
                }
                else if (nextLocation.action === Actions_1.PUSH) {
                    if (pushLocation(nextLocation) !== false) {
                        updateLocation(nextLocation, silence);
                    }
                }
                else if (nextLocation.action === Actions_1.REPLACE) {
                    if (replaceLocation(nextLocation) !== false) {
                        updateLocation(nextLocation, silence);
                    }
                }
            }
            else if (currentLocation && nextLocation.action === Actions_1.POP) {
                var prevIndex = allKeys.indexOf(currentLocation.key);
                var nextIndex = allKeys.indexOf(nextLocation.key);
                if (prevIndex !== -1 && nextIndex !== -1) {
                    go(prevIndex - nextIndex); // Restore the URL
                }
            }
        });
    }
    function push(input, silence) {
        if (silence === void 0) { silence = false; }
        transitionTo(createLocation(input, Actions_1.PUSH), silence);
    }
    function replace(input, silence) {
        if (silence === void 0) { silence = false; }
        transitionTo(createLocation(input, Actions_1.REPLACE), silence);
    }
    function goBack() {
        go(-1);
    }
    function goForward() {
        go(1);
    }
    function createKey() {
        return (Math
            .random()
            .toString(36)
            .substr(2, keyLength || 6));
    }
    function createLocation(location, action, key) {
        if (key === void 0) { key = createKey(); }
        return LocationUtils_1.createLocation(location, action, key);
    }
    function listenBefore(listener) {
        return startListener(listener, true);
    }
    function listen(listener) {
        return startListener(listener, false);
    }
    var goIsSupportedWithoutReload = DOMUtils_1.supportsGoWithoutReloadUsingHash();
    function go(n) {
        tiny_warning_1.default(goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser');
        history.go(n);
    }
    function createHref(location) {
        return '#' + pathCoder.encodePath(_createHref(location));
    }
    return {
        getCurrentLocation: getCurrentLocation,
        listenBefore: listenBefore,
        listen: listen,
        transitionTo: transitionTo,
        push: push,
        replace: replace,
        go: go,
        goBack: goBack,
        goForward: goForward,
        createKey: createKey,
        createPath: PathUtils_1.createPath,
        createHref: createHref,
        createLocation: createLocation
    };
}
exports.default = createHashHistory;
