"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var tiny_invariant_1 = __importDefault(require("tiny-invariant"));
var DOMUtils_1 = require("./DOMUtils");
var AsyncUtils_1 = require("./AsyncUtils");
var PathUtils_1 = require("./PathUtils");
var DOMStateStorage_1 = require("./DOMStateStorage");
var runTransitionHook_1 = __importDefault(require("./runTransitionHook"));
var LocationUtils_1 = require("./LocationUtils");
var Actions_1 = __importStar(require("./Actions"));
function isExtraneousPopstateEvent(event) {
    return (event.state === void 0
        && navigator.userAgent.indexOf('CriOS') === -1);
}
var PopStateEventState = 'popstate';
/**
 * createBrowserHistory
 *
 * Creates and returns a history object that uses HTML5's history API
 * (pushState, replaceState, and the popstate event) to manage history.
 * This is the recommended method of managing history in browsers because
 * it provides the cleanest URLs.
 *
 * Note: In browsers that do not support the HTML5 history API full
 * page reloads will be used to preserve clean URLs. You can force this
 * behavior using { forceRefresh: true } in options.
 */
function createBrowserHistory(options) {
    if (options === void 0) { options = { hashType: 'slash' }; }
    tiny_invariant_1.default(DOMUtils_1.canUseDOM, 'Browser history needs a DOM');
    // Browser
    function createBroserverLocation(historyState) {
        var key = (historyState && historyState.key) || '';
        return LocationUtils_1.createLocation({
            pathname: window.location.pathname,
            search: window.location.search,
            hash: window.location.hash,
            state: (key ? DOMStateStorage_1.readState(key) : void 0)
        }, void 0, key);
    }
    function startListenerBrowser(callback) {
        function handlePopState(event) {
            // Ignore extraneous popstate events in WebKit
            if (isExtraneousPopstateEvent(event))
                return;
            callback(createBroserverLocation(event.state));
        }
        DOMUtils_1.addEventListener(window, PopStateEventState, handlePopState);
        return function () {
            return DOMUtils_1.removeEventListener(window, PopStateEventState, handlePopState);
        };
    }
    function updateLocationBrow(location, updateState) {
        var state = location.state, key = location.key;
        if (state !== void 0) {
            DOMStateStorage_1.saveState(key, state);
        }
        updateState({ key: key }, PathUtils_1.createPath(location));
    }
    var getUserConfirmation = options.getUserConfirmation || LocationUtils_1.defaultGetUserConfirmation;
    function go(n) {
        if (n) {
            window.history.go(n);
        }
    }
    function getCurrentLocationBrow() {
        var historyState;
        try {
            historyState = window.history.state || {};
        }
        catch (error) {
            // IE 11 sometimes throws when accessing window.history.state
            // See https://github.com/ReactTraining/history/pull/289
            historyState = {};
        }
        return createBroserverLocation(historyState);
    }
    function pushLocationBrow(location) {
        updateLocationBrow(location, function (state, path) {
            return window.history.pushState(state, '', path);
        });
        return true;
    }
    function replaceLocationBrow(location) {
        updateLocationBrow(location, function (state, path) {
            return window.history.replaceState(state, '', path);
        });
        return true;
    }
    // Refresh
    function getCurrentLocationRefresh() {
        return LocationUtils_1.createLocation(window.location);
    }
    function pushLocationRefresh(location) {
        window.location.href = PathUtils_1.createPath(location);
        return false; // Don't update location
    }
    function replaceLocationRefresh(location) {
        window.location.replace(PathUtils_1.createPath(location));
        return false; // Don't update location
    }
    var useRefresh = options.forceRefresh || !DOMUtils_1.supportsHistory();
    var getCurrentLocation = useRefresh
        ? getCurrentLocationRefresh
        : getCurrentLocationBrow;
    var pushLocation = useRefresh
        ? pushLocationRefresh
        : pushLocationBrow;
    var replaceLocation = useRefresh
        ? replaceLocationRefresh
        : replaceLocationBrow;
    var keyLength = options.keyLength;
    var currentLocation;
    var pendingLocation;
    var beforeHooks = [];
    var hooks = [];
    var allKeys = [];
    function getCurrentIndex() {
        if (pendingLocation && pendingLocation.action === Actions_1.default.POP)
            return allKeys.indexOf(pendingLocation.key || '');
        if (currentLocation)
            return allKeys.indexOf(currentLocation.key || '');
        return -1;
    }
    function updateLocation(nextLocation, silence) {
        if (silence === void 0) { silence = false; }
        var currentIndex = getCurrentIndex();
        currentLocation = nextLocation;
        if (currentLocation.action === Actions_1.PUSH) {
            allKeys = __spread(allKeys.slice(0, currentIndex + 1), [currentLocation.key]);
        }
        else if (currentLocation.action === Actions_1.REPLACE) {
            allKeys[currentIndex] = currentLocation.key;
        }
        if (!silence) {
            hooks.forEach(function (hook) { return hook(currentLocation); });
        }
    }
    function listenBefore(listener) {
        return startListener(listener, true);
    }
    function listen(listener) {
        return startListener(listener, false);
    }
    function confirmTransitionTo(location, callback) {
        AsyncUtils_1.loopAsync(beforeHooks.length, function (index, next, done) {
            runTransitionHook_1.default(beforeHooks[index], location, function (result) {
                return result != null ? done(result) : next();
            });
        }, function (message) {
            if (getUserConfirmation && typeof message === 'string') {
                getUserConfirmation(message, function (ok) { return callback(ok !== false); });
            }
            else {
                callback(message !== false);
            }
        });
    }
    function transitionTo(nextLocation, silence) {
        if (silence === void 0) { silence = false; }
        if ((currentLocation && LocationUtils_1.locationsAreEqual(currentLocation, nextLocation)) ||
            (pendingLocation && LocationUtils_1.locationsAreEqual(pendingLocation, nextLocation))) {
            return; // Nothing to do
        }
        pendingLocation = nextLocation;
        confirmTransitionTo(nextLocation, function (ok) {
            if (pendingLocation !== nextLocation)
                return; // Transition was interrupted during confirmation
            pendingLocation = null;
            if (ok) {
                // Treat PUSH to same path like REPLACE to be consistent with browsers
                if (nextLocation.action === Actions_1.PUSH) {
                    var prevPath = PathUtils_1.createPath(currentLocation);
                    var nextPath = PathUtils_1.createPath(nextLocation);
                    if (nextPath === prevPath
                        && LocationUtils_1.statesAreEqual(currentLocation.state, nextLocation.state)) {
                        nextLocation.action = Actions_1.REPLACE;
                    }
                }
                if (nextLocation.action === Actions_1.POP) {
                    updateLocation(nextLocation, silence);
                }
                else if (nextLocation.action === Actions_1.PUSH) {
                    if (pushLocation(nextLocation) !== false) {
                        updateLocation(nextLocation, silence);
                    }
                }
                else if (nextLocation.action === Actions_1.REPLACE) {
                    if (replaceLocation(nextLocation) !== false) {
                        updateLocation(nextLocation, silence);
                    }
                }
            }
            else if (currentLocation && nextLocation.action === Actions_1.POP) {
                var prevIndex = allKeys.indexOf(currentLocation.key);
                var nextIndex = allKeys.indexOf(nextLocation.key);
                if (prevIndex !== -1 && nextIndex !== -1) {
                    go(prevIndex - nextIndex); // Restore the URL
                }
            }
        });
    }
    function push(input, silence) {
        if (silence === void 0) { silence = false; }
        transitionTo(createLocation(input, Actions_1.PUSH), silence);
    }
    function replace(input, silence) {
        if (silence === void 0) { silence = false; }
        transitionTo(createLocation(input, Actions_1.REPLACE), silence);
    }
    function goBack() {
        go(-1);
    }
    function goForward() {
        go(1);
    }
    function createKey() {
        return Math.random().toString(36).substr(2, keyLength || 6);
    }
    function createHref(location) {
        return PathUtils_1.createPath(location);
    }
    function createLocation(input, action, key) {
        if (key === void 0) { key = createKey(); }
        return LocationUtils_1.createLocation(input, action, key);
    }
    var listenerCount = 0;
    var stopListener;
    function _listenBefore(hook) {
        beforeHooks.push(hook);
        return function () {
            beforeHooks = beforeHooks.filter(function (item) { return item !== hook; });
        };
    }
    function _listen(hook) {
        hooks.push(hook);
        return function () {
            hooks = hooks.filter(function (item) { return item !== hook; });
        };
    }
    function startListener(listener, before) {
        if (++listenerCount === 1)
            stopListener = startListenerBrowser(transitionTo);
        var unlisten = before
            ? _listenBefore(listener)
            : _listen(listener);
        return function () {
            unlisten();
            if (--listenerCount === 0)
                stopListener();
        };
    }
    return {
        getCurrentLocation: getCurrentLocation,
        listenBefore: listenBefore,
        listen: listen,
        transitionTo: transitionTo,
        push: push,
        replace: replace,
        go: go,
        goBack: goBack,
        goForward: goForward,
        createKey: createKey,
        createPath: PathUtils_1.createPath,
        createHref: createHref,
        createLocation: createLocation
    };
}
exports.default = createBrowserHistory;
