"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var tiny_warning_1 = __importDefault(require("tiny-warning"));
var tiny_invariant_1 = __importDefault(require("tiny-invariant"));
var AsyncUtils_1 = require("./AsyncUtils");
var PathUtils_1 = require("./PathUtils");
var LocationUtils_1 = require("./LocationUtils");
var runTransitionHook_1 = __importDefault(require("./runTransitionHook"));
var Actions_1 = __importStar(require("./Actions"));
function createStateStorage(entries) {
    return entries
        .filter(function (entry) { return entry.state; })
        .reduce(function (memo, entry) {
        memo[entry.key] = entry.state;
        return memo;
    }, {});
}
function createMemoryHistory(options) {
    if (options === void 0) { options = { hashType: 'slash' }; }
    var getUserConfirmation = options.getUserConfirmation || LocationUtils_1.defaultGetUserConfirmation;
    var currentLocation;
    var pendingLocation;
    var beforeHooks = [];
    var hooks = [];
    var allKeys = [];
    function getCurrentIndex() {
        if (pendingLocation && pendingLocation.action === Actions_1.default.POP)
            return allKeys.indexOf(pendingLocation.key || '');
        if (currentLocation)
            return allKeys.indexOf(currentLocation.key || '');
        return -1;
    }
    function updateLocation(nextLocation, silence) {
        if (silence === void 0) { silence = false; }
        var currentIndex = getCurrentIndex();
        currentLocation = nextLocation;
        if (currentLocation.action === Actions_1.PUSH) {
            allKeys = __spread(allKeys.slice(0, currentIndex + 1), [currentLocation.key]);
        }
        else if (currentLocation.action === Actions_1.REPLACE) {
            allKeys[currentIndex] = currentLocation.key;
        }
        if (!silence) {
            hooks.forEach(function (hook) { return hook(currentLocation); });
        }
    }
    function listenBefore(hook) {
        beforeHooks.push(hook);
        return function () {
            return beforeHooks = beforeHooks.filter(function (item) { return item !== hook; });
        };
    }
    function listen(hook) {
        hooks.push(hook);
        return function () {
            return hooks = hooks.filter(function (item) { return item !== hook; });
        };
    }
    function confirmTransitionTo(location, callback) {
        AsyncUtils_1.loopAsync(beforeHooks.length, function (index, next, done) {
            runTransitionHook_1.default(beforeHooks[index], location, function (result) {
                return result != null ? done(result) : next();
            });
        }, function (message) {
            if (getUserConfirmation && typeof message === 'string') {
                getUserConfirmation(message, function (ok) { return callback(ok !== false); });
            }
            else {
                callback(message !== false);
            }
        });
    }
    function transitionTo(nextLocation, silence) {
        if (silence === void 0) { silence = false; }
        if ((currentLocation && LocationUtils_1.locationsAreEqual(currentLocation, nextLocation)) ||
            (pendingLocation && LocationUtils_1.locationsAreEqual(pendingLocation, nextLocation))) {
            return; // Nothing to do
        }
        pendingLocation = nextLocation;
        confirmTransitionTo(nextLocation, function (ok) {
            if (pendingLocation !== nextLocation)
                return; // Transition was interrupted during confirmation
            pendingLocation = null;
            if (ok) {
                // Treat PUSH to same path like REPLACE to be consistent with browsers
                if (nextLocation.action === Actions_1.PUSH) {
                    var prevPath = PathUtils_1.createPath(currentLocation);
                    var nextPath = PathUtils_1.createPath(nextLocation);
                    if (nextPath === prevPath
                        && LocationUtils_1.statesAreEqual(currentLocation.state, nextLocation.state)) {
                        nextLocation.action = Actions_1.REPLACE;
                    }
                }
                if (nextLocation.action === Actions_1.POP) {
                    updateLocation(nextLocation, silence);
                }
                else if (nextLocation.action === Actions_1.PUSH) {
                    if (pushLocation(nextLocation) !== false) {
                        updateLocation(nextLocation, silence);
                    }
                }
                else if (nextLocation.action === Actions_1.REPLACE) {
                    if (replaceLocation(nextLocation) !== false) {
                        updateLocation(nextLocation, silence);
                    }
                }
            }
            else if (currentLocation && nextLocation.action === Actions_1.POP) {
                var prevIndex = allKeys.indexOf(currentLocation.key);
                var nextIndex = allKeys.indexOf(nextLocation.key);
                if (prevIndex !== -1 && nextIndex !== -1) {
                    go(prevIndex - nextIndex); // Restore the URL
                }
            }
        });
    }
    function push(input, silence) {
        if (silence === void 0) { silence = false; }
        transitionTo(createLocation(input, Actions_1.PUSH), silence);
    }
    function replace(input, silence) {
        if (silence === void 0) { silence = false; }
        transitionTo(createLocation(input, Actions_1.REPLACE), silence);
    }
    function goBack() {
        go(-1);
    }
    function goForward() {
        go(1);
    }
    function createKey() {
        return Math.random().toString(36).substr(2, 6);
    }
    function createHref(location) {
        return PathUtils_1.createPath(location);
    }
    function createLocation(input, action, key) {
        if (key === void 0) { key = createKey(); }
        return LocationUtils_1.createLocation(input, action, key);
    }
    function getCurrentLocation() {
        if (typeof entries[current] !== void 0) {
            var entry = entries[current];
            var path = PathUtils_1.createPath(entry);
            var key = '';
            var state = void 0;
            if (entry && entry.key) {
                key = entry.key;
                state = readState(key);
            }
            var init = PathUtils_1.parsePath(path);
            return LocationUtils_1.createLocation(__assign(__assign({}, init), { state: state }), void 0, key);
        }
        else {
            throw new Error('current location is not exist.');
        }
    }
    function canGo(n) {
        var index = current + n;
        return index >= 0 && index < entries.length;
    }
    function go(n) {
        if (!n)
            return;
        if (!canGo(n)) {
            tiny_warning_1.default(false, "Cannot go(" + n + ") there is not enough history when current is " + current + " and entries length is " + entries.length);
            return;
        }
        current += n;
        var currentLocation = getCurrentLocation();
        // Change action to POP
        transitionTo(__assign(__assign({}, currentLocation), { action: Actions_1.POP }));
    }
    function pushLocation(location) {
        current += 1;
        if (current < entries.length) {
            entries.splice(current);
        }
        entries.push(location);
        saveState(location.key, location.state);
        return true;
    }
    function replaceLocation(location) {
        entries[current] = location;
        saveState(location.key, location.state);
        return true;
    }
    var entriesBefore;
    if (typeof options.entries === 'string') {
        entriesBefore = [options.entries];
    }
    else if (!Array.isArray(options.entries)) {
        entriesBefore = ['/'];
    }
    else {
        entriesBefore = options.entries;
    }
    var entries = entriesBefore.map(function (entry) { return LocationUtils_1.createLocation(entry); });
    var current = options.current || entries.length - 1;
    tiny_invariant_1.default(current >= 0 && current < entries.length, "Current index must be >= 0 and < " + entries.length + ", was " + current);
    var storage = createStateStorage(entries);
    function saveState(key, state) {
        return storage[key] = state;
    }
    function readState(key) {
        return storage[key];
    }
    return {
        getCurrentLocation: getCurrentLocation,
        listenBefore: listenBefore,
        listen: listen,
        transitionTo: transitionTo,
        push: push,
        replace: replace,
        go: go,
        goBack: goBack,
        goForward: goForward,
        createKey: createKey,
        createPath: PathUtils_1.createPath,
        createHref: createHref,
        createLocation: createLocation
    };
}
exports.default = createMemoryHistory;
