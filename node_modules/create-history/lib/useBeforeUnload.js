"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var tiny_invariant_1 = __importDefault(require("tiny-invariant"));
var DOMUtils_1 = require("./DOMUtils");
var DOMUtils_2 = require("./DOMUtils");
function startListener(getPromptMessage) {
    function handleBeforeUnload(event) {
        var message = getPromptMessage();
        if (typeof message === 'string') {
            event.returnValue = message;
            return message;
        }
        return void 0;
    }
    DOMUtils_1.addEventListener(window, 'beforeunload', handleBeforeUnload);
    return function () { return (DOMUtils_1.removeEventListener(window, 'beforeunload', handleBeforeUnload)); };
}
/**
 * Returns a new createHistory function that can be used to create
 * history objects that know how to use the beforeunload event in web
 * browsers to cancel navigation.
 */
function useBeforeUnload(createHistory) {
    tiny_invariant_1.default(DOMUtils_2.canUseDOM, 'useBeforeUnload only works in DOM environments');
    function ch(options) {
        var history = createHistory(options);
        var hooks = [];
        var stopListener;
        function getPromptMessage() {
            var message;
            for (var i = 0, len = hooks.length; message == null && i < len; ++i) {
                message = hooks[i]();
            }
            return message;
        }
        function listenBeforeUnload(hook) {
            if (hooks.push(hook) === 1) {
                stopListener = startListener(getPromptMessage);
            }
            return function () {
                hooks = hooks.filter(function (item) { return item !== hook; });
                if (hooks.length === 0 && stopListener) {
                    stopListener();
                    stopListener = null;
                }
            };
        }
        return __assign(__assign({}, history), { listenBeforeUnload: listenBeforeUnload });
    }
    return ch;
}
exports.default = useBeforeUnload;
